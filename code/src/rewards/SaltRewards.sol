// SPDX-License-Identifier: BUSL 1.1
pragma solidity =0.8.22;

import "openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol";
import "../rewards/interfaces/IRewardsEmitter.sol";
import "../rewards/interfaces/IRewardsConfig.sol";
import "../interfaces/IExchangeConfig.sol";
import "./interfaces/ISaltRewards.sol";
import "../interfaces/ISalt.sol";
import "../pools/PoolUtils.sol";


// A utility contract that temporarily holds SALT rewards from emissions and arbitrage profits during performUpkeep().
// Sends SALT rewards to the stakingRewardsEmitter and liquidityRewardsEmitter (with proportions for the latter based on each pool's share in generating recent arbitrage profits).
contract SaltRewards is ISaltRewards
    {
    using SafeERC20 for ISalt;

	IRewardsEmitter immutable public stakingRewardsEmitter;
	IRewardsEmitter immutable public liquidityRewardsEmitter;
	IExchangeConfig immutable public exchangeConfig;
	IRewardsConfig immutable public rewardsConfig;
	ISalt immutable public salt;

	bytes32 immutable saltUSDSPoolID;


    constructor( IRewardsEmitter _stakingRewardsEmitter, IRewardsEmitter _liquidityRewardsEmitter, IExchangeConfig _exchangeConfig, IRewardsConfig _rewardsConfig )
		{
		stakingRewardsEmitter = _stakingRewardsEmitter;
		liquidityRewardsEmitter = _liquidityRewardsEmitter;
		exchangeConfig = _exchangeConfig;
		rewardsConfig = _rewardsConfig;

		// Cached for efficiency
		salt = _exchangeConfig.salt();
		saltUSDSPoolID = PoolUtils._poolID(salt, _exchangeConfig.usds());

		// Gas saving approval for rewards distribution on performUpkeep().
		// This contract only has a temporary SALT balance during the performUpkeep transaction.
		salt.approve( address(stakingRewardsEmitter), type(uint256).max );
		salt.approve( address(liquidityRewardsEmitter), type(uint256).max );
		}


	// Send the pending SALT rewards to the stakingRewardsEmitter
	function _sendStakingRewards(uint256 stakingRewardsAmount) internal
		{
		AddedReward[] memory addedRewards = new AddedReward[](1);
		addedRewards[0] = AddedReward( PoolUtils.STAKED_SALT, stakingRewardsAmount );

		stakingRewardsEmitter.addSALTRewards(addedRewards);
		}


	// Transfer SALT rewards to pools in the liquidityRewardsEmitter proportional to each pool's share in generating recent arbitrage profits.
	// Also send the direct rewards specified by the DAO to the SALT/USDS pool.
	function _sendLiquidityRewards( uint256 liquidityRewardsAmount, uint256 directRewardsForSaltUSDS, bytes32[] memory poolIDs, uint256[] memory profitsForPools, uint256 totalProfits ) internal
		{
		require( poolIDs.length == profitsForPools.length, "Incompatible array lengths" );

		// Send SALT rewards (with an amount of pendingLiquidityRewards) proportional to the profits generated by each pool
		AddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );
		for( uint256 i = 0; i < addedRewards.length; i++ )
			{
			bytes32 poolID = poolIDs[i];
			uint256 rewardsForPool = ( liquidityRewardsAmount * profitsForPools[i] ) / totalProfits;

			// The SALT/USDS pool is entitled to additional rewards - as specified by RewardsConfig.percentRewardsSaltUSDS
			if ( poolID == saltUSDSPoolID )
				rewardsForPool += directRewardsForSaltUSDS;

			addedRewards[i] = AddedReward( poolID, rewardsForPool );
			}

		// Send the SALT rewards to the LiquidityRewardsEmitter
		liquidityRewardsEmitter.addSALTRewards( addedRewards );
		}


	function _sendInitialLiquidityRewards( uint256 liquidityBootstrapAmount, bytes32[] memory poolIDs ) internal
		{
		// Divide the liquidityBootstrapAmount evenly across all the initial pools
		uint256 amountPerPool = liquidityBootstrapAmount / poolIDs.length; // poolIDs.length is guaranteed to not be zero

		AddedReward[] memory addedRewards = new AddedReward[]( poolIDs.length );
		for( uint256 i = 0; i < addedRewards.length; i++ )
			addedRewards[i] = AddedReward( poolIDs[i], amountPerPool );

		// Send the liquidity bootstrap rewards to the liquidityRewardsEmitter
		liquidityRewardsEmitter.addSALTRewards( addedRewards );
		}


	function _sendInitialStakingRewards( uint256 stakingBootstrapAmount ) internal
		{
		// Send the stakingBootstrapAmount to the stakingRewardsEmitter
		AddedReward[] memory addedRewards = new AddedReward[](1);
		addedRewards[0] = AddedReward( PoolUtils.STAKED_SALT, stakingBootstrapAmount );

		stakingRewardsEmitter.addSALTRewards( addedRewards );
		}


    // Sends an expected 5 million SALT to the liquidityRewardsEmitter (evenly divided amongst the pools) and 3 million SALT to the stakingRewardsEmitter.
	function sendInitialSaltRewards( uint256 liquidityBootstrapAmount, bytes32[] calldata poolIDs ) external
		{
		require( msg.sender == address(exchangeConfig.initialDistribution()), "SaltRewards.sendInitialRewards is only callable from the InitialDistribution contract" );

		_sendInitialLiquidityRewards(liquidityBootstrapAmount, poolIDs);

		// Remaining SALT balance goes to stakingRewardsEmitter
		_sendInitialStakingRewards( salt.balanceOf(address(this)) );
		}


	function performUpkeep( bytes32[] calldata poolIDs, uint256[] calldata profitsForPools ) external
		{
		require( msg.sender == address(exchangeConfig.upkeep()), "SaltRewards.performUpkeep is only callable from the Upkeep contract" );
		require( poolIDs.length == profitsForPools.length, "Incompatible array lengths" );

		// Distribute all SALT currently in the contract.
		uint256 saltRewardsToDistribute = salt.balanceOf(address(this));
		if ( saltRewardsToDistribute == 0 )
			return;

		// Determine the total profits so we can calculate proportional share for the liquidity rewards
		uint256 totalProfits = 0;
		for( uint256 i = 0; i < poolIDs.length; i++ )
			totalProfits += profitsForPools[i];

		// Make sure that there are some profits to determine the proportional liquidity rewards.
		// Otherwise just handle the SALT balance later so it can be divided between stakingRewardsEmitter and liquidityRewardsEmitter without further accounting.
		if ( totalProfits == 0 )
			return;

		// Determine how much of the SALT rewards will be directly awarded to the SALT/USDS pool.
		// This is because SALT/USDS is important, but not included in other arbitrage trades - which would normally yield additional rewards for the pool by being part of arbitrage swaps.
		uint256 directRewardsForSaltUSDS = ( saltRewardsToDistribute * rewardsConfig.percentRewardsSaltUSDS() ) / 100;
		uint256 remainingRewards = saltRewardsToDistribute - directRewardsForSaltUSDS;

		// Divide up the remaining rewards between SALT stakers and liquidity providers
		uint256 stakingRewardsAmount = ( remainingRewards * rewardsConfig.stakingRewardsPercent() ) / 100;
		uint256 liquidityRewardsAmount = remainingRewards - stakingRewardsAmount;

		_sendStakingRewards(stakingRewardsAmount);
		_sendLiquidityRewards(liquidityRewardsAmount, directRewardsForSaltUSDS, poolIDs, profitsForPools, totalProfits);
		}
	}
